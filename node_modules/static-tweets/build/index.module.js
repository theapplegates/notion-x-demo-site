import GithubSlugger from 'github-slugger';
import vercelFetch from '@vercel/fetch';
import cheerio from 'cheerio';
import 'path';
import { resolve } from 'url';
import unified from 'unified';
import markdown from 'remark-parse';
import remarkToRehype from 'remark-rehype';
import raw from 'rehype-raw';
import prism from '@mapbox/rehype-prism';
import parse from 'rehype-parse';
import sanitize from 'rehype-sanitize';

var fetch = vercelFetch();

const API_URL = 'https://api.twitter.com';
const SYNDICATION_URL = 'https://syndication.twitter.com';

function twitterLabsEnabled(expansions) {
  if (process.env.TWITTER_LABS_ENABLED !== 'true') return false;
  if (!expansions) return true;
  const exp = process.env.TWITTER_LABS_EXPANSIONS || '';
  return exp.includes(expansions);
}

async function fetchTweetsHtml(ids) {
  const res = await fetch(`${SYNDICATION_URL}/tweets.json?ids=${ids}`);
  if (res.ok) return res.json();
  if (res.status === 404) return {};
  throw new Error(`Fetch for the embedded tweets of "${ids}" failed with code: ${res.status}`);
}
async function fetchTweetHtml(id) {
  const html = await fetchTweetsHtml(id);
  return html[id];
}
async function fetchUserStatus(tweetId) {
  // If there isn't an API token don't do anything, this is only required for videos.
  if (!process.env.TWITTER_ACCESS_TOKEN) return;
  const res = await fetch(`${API_URL}/1.1/statuses/show/${tweetId}.json?include_entities=true&tweet_mode=extended`, {
    headers: {
      authorization: `Bearer ${process.env.TWITTER_ACCESS_TOKEN}`
    }
  });
  console.log('Twitter x-rate-limit-limit:', res.headers.get('x-rate-limit-limit'));
  console.log('Twitter x-rate-limit-remaining:', res.headers.get('x-rate-limit-remaining'));
  console.log('Twitter x-rate-limit-reset:', res.headers.get('x-rate-limit-reset'));
  if (res.ok) return res.json();
  if (res.status === 404) return;
  throw new Error(`Fetch to the Twitter API failed with code: ${res.status}`);
}
async function fetchTweetWithPoll(tweetId) {
  const expansions = 'attachments.poll_ids'; // If there isn't an API token or Twitter Labs is not enabled, don't do anything,
  // this is only required for Polls.

  if (!process.env.TWITTER_ACCESS_TOKEN || !twitterLabsEnabled(expansions)) return;
  const res = await fetch(`${API_URL}/labs/1/tweets?format=compact&expansions=${expansions}&ids=${tweetId}`, {
    headers: {
      authorization: `Bearer ${process.env.TWITTER_ACCESS_TOKEN}`
    }
  });
  console.log('Twitter Labs x-rate-limit-limit:', res.headers.get('x-rate-limit-limit'));
  console.log('Twitter Labs x-rate-limit-remaining:', res.headers.get('x-rate-limit-remaining'));
  console.log('Twitter Labs x-rate-limit-reset:', res.headers.get('x-rate-limit-reset'));
  if (res.ok) return res.json();
  if (res.status === 404) return;
  throw new Error(`Fetch to the Twitter Labs API failed with code: ${res.status}`);
}
async function getEmbeddedTweetHtml(url) {
  const res = await fetch(`https://publish.twitter.com/oembed?url=${url}`);
  if (res.ok) return res.json();
  if (res.status === 404) return;
  throw new Error(`Fetch for embedded tweet failed with code: ${res.status}`);
}

function getTweetContent($) {
  const container = $('.EmbeddedTweet-tweetContainer');
  if (!container.length) return;
  const meta = {};
  const content = {
    meta
  }; // This is the blockquote with the tweet

  const subject = container.find('[data-scribe="section:subject"]'); // Tweet header with the author info

  const header = subject.children('.Tweet-header');
  const avatar = header.find('[data-scribe="element:avatar"]');
  const author = header.find('[data-scribe="component:author"]');
  const name = author.find('[data-scribe="element:name"]');
  const screenName = author.find('[data-scribe="element:screen_name"]'); // Tweet body

  const tweet = subject.children('[data-scribe="component:tweet"]');
  const tweetContent = tweet.children('p');
  const card = tweet.children('.Tweet-card');
  const tweetInfo = tweet.children('.TweetInfo');
  const fullTimestamp = tweetInfo.find('[data-scribe="element:full_timestamp"]');
  const heartCount = tweetInfo.find('[data-scribe="element:heart_count"]'); // Tweet footer

  const callToAction = container.children('[data-scribe="section:cta component:news"]');
  const profileText = callToAction.children('[data-scribe="element:profile_text"]');
  const conversationText = callToAction.children('[data-scribe="element:conversation_text"]');
  let quotedTweet;
  let mediaHtml;
  meta.id = subject.attr('data-tweet-id');
  meta.avatar = {
    normal: avatar.attr('data-src-1x')
  };
  meta.name = name.text();
  meta.username = screenName.text().substring(1); // Omit the initial @

  meta.createdAt = new Date(fullTimestamp.attr('data-datetime')).getTime();
  meta.heartCount = heartCount.text();
  meta.ctaType = profileText.length ? 'profile' : 'conversation';

  if (conversationText.length) {
    // Get the formatted count and skip the rest
    meta.ctaCount = conversationText.text().match(/^[^\s]+/)[0];
  } // If some text ends without a trailing space, it's missing a <br>


  tweetContent.contents().each(function () {
    const el = $(this);
    const type = el[0].type;
    if (type !== 'text') return;
    const text = el.text();

    if (text.length && text.trim() === '') {
      if (el.next().children().length) {
        el.after($('<br>'));
      }
    } else if (!/\s$/.test(el.text()) && el.next().children().length && !/^[#@]/.test(el.next().text())) {
      el.after($('<br>'));
    }
  });
  card.children().each(function () {
    const props = this.attribs;
    const scribe = props['data-scribe'];
    const el = $(this);

    if (scribe === 'section:quote') {
      const tweetCard = el.children('a');
      const id = tweetCard.attr('data-tweet-id');
      const url = tweetCard.attr('href');
      quotedTweet = {
        id,
        url
      };
      return;
    }

    const media = $('<div>');

    if (scribe === 'component:card') {
      const photo = el.children('[data-scribe="element:photo"]');
      const photoGrid = el.children('[data-scribe="element:photo_grid"]');
      const photos = photo.length ? photo : photoGrid;

      if (photos.length) {
        const images = photos.find('img');
        images.each(function () {
          const img = $(this);
          const alt = img.attr('alt');
          const url = img.attr('data-image');
          const format = img.attr('data-image-format');
          const height = img.attr('height');
          const width = img.attr('width');
          this.attribs = {
            'data-type': 'media-image',
            src: `${url}?format=${format}`,
            height,
            width
          };

          if (alt) {
            this.attribs.alt = alt;
          } // Move the media img to a new container


          media.append(img);
        });
        media.attr('data-type', `image-container ${images.length}`);
        mediaHtml = $('<div>').append(media).html();
      }
    }
  });
  tweetContent.children('img').each(function () {
    var _props$class;

    const props = this.attribs; // Handle emojis inside the text

    if ((_props$class = props.class) != null && _props$class.includes('Emoji--forText')) {
      this.attribs = {
        'data-type': 'emoji-for-text',
        src: props.src,
        alt: props.alt
      };
      return;
    }

    console.error('An image with the following props is not being handled:', props);
  });
  tweetContent.children('a').each(function () {
    const props = this.attribs;
    const scribe = props['data-scribe'];
    const el = $(this);

    const asTwitterLink = type => {
      this.attribs = {
        'data-type': type,
        href: props.href
      }; // Replace custom tags inside the anchor with text

      el.text(el.text());
    }; // @mention


    if (scribe === 'element:mention') {
      return asTwitterLink('mention');
    } // #hashtag


    if (scribe === 'element:hashtag') {
      // A hashtag may be a $cashtag too
      const type = props['data-query-source'] === 'cashtag_click' ? 'cashtag' : 'hashtag';
      return asTwitterLink(type);
    }

    if (scribe === 'element:url') {
      const url = props['data-expanded-url']; // const quotedTweetId = props['data-tweet-id']
      // Remove link to quoted tweet to leave the card only
      // if (quotedTweetId && quotedTweetId === quotedTweet?.id) {
      //   el.remove();
      //   return;
      // }
      // Handle normal links

      const text = {
        type: 'text',
        data: url
      }; // Replace the link with plain text and markdown will take care of it

      el.replaceWith(text);
    }
  });
  content.html = tweetContent.html();
  if (quotedTweet) content.quotedTweet = quotedTweet;
  if (mediaHtml) content.mediaHtml = mediaHtml;
  return content;
}

function getTweetData(html) {
  const $ = cheerio.load(html, {
    decodeEntities: false,
    xmlMode: false
  });
  const tweetContent = getTweetContent($);
  return tweetContent;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function getVideo(html, {
  poster,
  url
}) {
  const $ = cheerio.load(html, {
    decodeEntities: false,
    xmlMode: false
  });
  const container = $('[data-type=video-container]');
  const video = $(`<video poster="${poster}" controls preload="none" playsinline>`).append(`<source src="${url}" type="video/mp4">`);
  return $('<div>').append(container.append(video)).html();
}

const handlers = {
  // Add a className to inlineCode so we can differentiate between it and code fragments
  inlineCode(_, node) {
    return _extends({}, node, {
      type: 'element',
      tagName: 'code',
      properties: {
        className: 'inline'
      },
      children: [{
        type: 'text',
        value: node.value
      }]
    });
  }

};

function toAst() {
  this.Compiler = tree => tree;
} // Create the processor, the order of the plugins is important


const processor = unified().use(markdown).use(remarkToRehype, {
  handlers,
  allowDangerousHtml: true
}) // Add custom HTML found in the tweet to the AST
.use(raw) // Add syntax highlighting
.use(prism).use(toAst);
async function markdownToAst(md) {
  try {
    const file = await processor.process(md);
    return file.result;
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`Markdown to AST error: ${error}`);
    throw error;
  }
}

function getVideoData(userStatus) {
  const video = userStatus.extended_entities.media[0];
  const poster = video.media_url_https; // Find the first mp4 video in the array, if the results are always properly sorted, then
  // it should always be the mp4 video with the lowest bitrate

  const mp4Video = video.video_info.variants.find(v => v.content_type === 'video/mp4');
  if (!mp4Video) return;
  return _extends({
    poster
  }, mp4Video);
}

function getPollData(tweet) {
  const polls = tweet.includes && tweet.includes.polls;
  return polls && polls[0];
}

async function getMediaHtml(tweet) {
  let media = tweet.mediaHtml;

  if (tweet.hasVideo) {
    const userStatus = await fetchUserStatus(tweet.meta.id);
    const video = userStatus && getVideoData(userStatus);
    media = video ? getVideo(media, video) : null;
  }

  return media;
}

async function getQuotedTweetHtml({
  quotedTweet
}, context) {
  if (!quotedTweet) return;

  if (process.env.NEXT_PUBLIC_TWITTER_LOAD_WIDGETS === 'true') {
    const data = await getEmbeddedTweetHtml(quotedTweet.url);
    return data == null ? void 0 : data.html;
  } else {
    const ast = await fetchTweetAst(quotedTweet.id); // The AST of embedded tweets is always sent as data

    return ast && `<blockquote data-id="${context.add({
      ast
    })}"></blockquote>`;
  }
}

async function getPollHtml(tweet, context) {
  if (!tweet.hasPoll) return null;
  const tweetData = await fetchTweetWithPoll(tweet.meta.id);
  const poll = tweetData && getPollData(tweetData);

  if (poll) {
    const meta = {
      type: 'poll-container',
      endsAt: poll.end_datetime,
      duration: poll.duration_minutes,
      status: poll.voting_status,
      options: poll.options
    };
    return `<div data-id="${context.add(meta)}"></div>`;
  }

  return null;
}

async function getTweetHtml(tweet, context) {
  const meta = _extends({}, tweet.meta, {
    type: 'tweet'
  });

  const md = await markdownToAst(tweet.html);
  const html = [// md.children is the markdown content, which is later added as children to the container
  `<div data-id="${context.add(meta, md.children)}">`, (await getMediaHtml(tweet)) || '', (await getQuotedTweetHtml(tweet, context)) || '', (await getPollHtml(tweet, context)) || '', `</div>`].join('');
  return html;
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 *
 * @typedef {string} Type
 * @typedef {Object<string, unknown>} Props
 *
 * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test
 */

var convert =
  /**
   * @type {(
   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * Generate an assertion from a check.
     * @param {Test} [test]
     * When nullish, checks if `node` is a `Node`.
     * When `string`, works like passing `function (node) {return node.type === test}`.
     * When `function` checks if function passed the node is true.
     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
     * When `array`, checks any one of the subtests pass.
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        // @ts-ignore looks like a list of tests / partial test object.
        return 'length' in test ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  );
/**
 * @param {Array.<Type|Props|TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array.<AssertAnything>} */
  var checks = [];
  var index = -1;

  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {unknown[]} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    var index = -1;

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }
  }
}

/**
 * Utility to assert each property in `test` is represented in `node`, and each
 * values are strictly equal.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    var key;

    for (key in check) {
      if (node[key] !== check[key]) return
    }

    return true
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 *
 * @param {Type} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Utility to convert a string into a function which checks a given node’s type
 * for said string.
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {Array.<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters))
  }
}

// Utility to return true.
function ok() {
  return true
}

/**
 * @param {string} d
 * @returns {string}
 */
function color(d) {
  return '\u001B[33m' + d + '\u001B[39m'
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */

/**
 * Continue traversing as normal
 */
const CONTINUE = true;
/**
 * Do not traverse this node’s children
 */
const SKIP = 'skip';
/**
 * Stop traversing immediately
 */
const EXIT = false;

const visitParents =
  /**
   * @type {(
   *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &
   *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &
   *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)
   * )}
   */
  (
    /**
     * Visit children of tree which pass a test
     *
     * @param {Node} tree Abstract syntax tree to walk
     * @param {Test} test test Test node
     * @param {Visitor<Node>} visitor Function to run for each node
     * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        // @ts-ignore no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
      }

      var is = convert(test);
      var step = reverse ? -1 : 1;

      factory(tree, null, [])();

      /**
       * @param {Node} node
       * @param {number?} index
       * @param {Array.<Parent>} parents
       */
      function factory(node, index, parents) {
        /** @type {Object.<string, unknown>} */
        var value = typeof node === 'object' && node !== null ? node : {};
        /** @type {string} */
        var name;

        if (typeof value.type === 'string') {
          name =
            typeof value.tagName === 'string'
              ? value.tagName
              : typeof value.name === 'string'
              ? value.name
              : undefined;

          Object.defineProperty(visit, 'name', {
            value:
              'node (' +
              color(value.type + (name ? '<' + name + '>' : '')) +
              ')'
          });
        }

        return visit

        function visit() {
          /** @type {ActionTuple} */
          var result = [];
          /** @type {ActionTuple} */
          var subresult;
          /** @type {number} */
          var offset;
          /** @type {Array.<Parent>} */
          var grandparents;

          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents));

            if (result[0] === EXIT) {
              return result
            }
          }

          if (node.children && result[0] !== SKIP) {
            // @ts-ignore looks like a parent.
            offset = (reverse ? node.children.length : -1) + step;
            // @ts-ignore looks like a parent.
            grandparents = parents.concat(node);

            // @ts-ignore looks like a parent.
            while (offset > -1 && offset < node.children.length) {
              subresult = factory(node.children[offset], offset, grandparents)();

              if (subresult[0] === EXIT) {
                return subresult
              }

              offset =
                typeof subresult[1] === 'number' ? subresult[1] : offset + step;
            }
          }

          return result
        }
      }
    }
  );

/**
 * @param {VisitorResult} value
 * @returns {ActionTuple}
 */
function toResult(value) {
  if (Array.isArray(value)) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */

const visit =
  /**
   * @type {(
   *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &
   *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &
   *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)
   * )}
   */
  (
    /**
     * Visit children of tree which pass a test
     *
     * @param {Node} tree Abstract syntax tree to walk
     * @param {Test} test test Test node
     * @param {Visitor<Node>} visitor Function to run for each node
     * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        visitor = test;
        test = null;
      }

      visitParents(tree, test, overload, reverse);

      /**
       * @param {Node} node
       * @param {Array.<Parent>} parents
       */
      function overload(node, parents) {
        var parent = parents[parents.length - 1];
        return visitor(
          node,
          parent ? parent.children.indexOf(node) : null,
          parent
        )
      }
    }
  );

/**
 * @typedef Options
 * @property {boolean} [includeImageAlt=true]
 */

/**
 * Get the text content of a node.
 * Prefer the node’s plain-text fields, otherwise serialize its children,
 * and if the given value is an array, serialize the nodes in it.
 *
 * @param {unknown} node
 * @param {Options} [options]
 * @returns {string}
 */
function toString(node, options) {
  var {
    includeImageAlt = true
  } = options || {};
  return one(node, includeImageAlt);
}
/**
 * @param {unknown} node
 * @param {boolean} includeImageAlt
 * @returns {string}
 */

function one(node, includeImageAlt) {
  return node && typeof node === 'object' && ( // @ts-ignore looks like a literal.
  node.value || ( // @ts-ignore looks like an image.
  includeImageAlt ? node.alt : '') || // @ts-ignore looks like a parent.
  'children' in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || '';
}
/**
 * @param {Array.<unknown>} values
 * @param {boolean} includeImageAlt
 * @returns {string}
 */


function all(values, includeImageAlt) {
  /** @type {Array.<string>} */
  var result = [];
  var index = -1;

  while (++index < values.length) {
    result[index] = one(values[index], includeImageAlt);
  }

  return result.join('');
}

const TWITTER_URL = 'https://twitter.com';
const ABSOLUTE_URL = /^https?:\/\/|^\/\//i;
const HEADINGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

function visitAnchor(node) {
  if (!node.properties) return;
  const {
    href
  } = node.properties;
  if (!href) return;
  const isAbsoluteUrl = ABSOLUTE_URL.test(href);

  if (!isAbsoluteUrl) {
    node.properties.href = resolve(TWITTER_URL, href);
  }
}

function rehypeTweet(context) {
  // Nodes may have custom data required by the UI
  function visitData(node) {
    const ctx = context.get(node.properties.dataId);
    if (ctx != null && ctx.data) node.data = ctx.data; // Add markdown content to the tweet container

    if (ctx != null && ctx.nodes) {
      node.children.unshift(...ctx.nodes);
    }

    delete node.properties.dataId;
  }

  function visitHeading(node) {
    const text = toString(node);
    if (!text) return;
    const id = context.slugger.slug(text);
    node.data = {
      id
    };
  }

  return function transformer(tree) {
    visit(tree, node => {
      var _node$properties;

      return (_node$properties = node.properties) == null ? void 0 : _node$properties.dataId;
    }, visitData);
    visit(tree, node => node.tagName === 'a', visitAnchor);
    visit(tree, node => HEADINGS.includes(node.tagName), visitHeading);
  };
}

function minifyAst(ast) {
  if (Array.isArray(ast)) {
    return ast.reduce((nodes, node) => {
      var _nodes;

      const n = minifyAst(node); // Empty new lines aren't required

      const isNoise = n === '\n' && ((_nodes = nodes[nodes.length - 1]) == null ? void 0 : _nodes.tag) !== 'span';
      if (!isNoise) nodes.push(n);
      return nodes;
    }, []);
  } // Handle the root ast


  if (!ast.tagName && ast.children) {
    return minifyAst(ast.children);
  }

  if (ast.type === 'text') {
    return ast.value;
  }

  if (ast.type === 'element') {
    var _ast$children;

    const node = {
      tag: ast.tagName
    };
    const children = (_ast$children = ast.children) != null && _ast$children.length ? minifyAst(ast.children) : [];

    if (ast.properties && Object.keys(ast.properties).length) {
      node.props = ast.properties;
    }

    if (ast.data) {
      node.data = ast.data;
    }

    if (children.length) {
      node.nodes = children;
    }

    return node;
  }

  throw new Error(`Unable to handle the following AST: ${JSON.stringify(ast, null, 2)}`);
}

function rehypeMinify() {
  this.Compiler = tree => minifyAst(tree);
}

/** @type {import('./index.js').Schema} */
const defaultSchema = {
  strip: ['script'],
  clobberPrefix: 'user-content-',
  clobber: ['name', 'id'],
  ancestors: {
    tbody: ['table'],
    tfoot: ['table'],
    thead: ['table'],
    td: ['table'],
    th: ['table'],
    tr: ['table']
  },
  protocols: {
    href: ['http', 'https', 'mailto', 'xmpp', 'irc', 'ircs'],
    cite: ['http', 'https'],
    src: ['http', 'https'],
    longDesc: ['http', 'https']
  },
  tagNames: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'br', 'b', 'i', 'strong', 'em', 'a', 'pre', 'code', 'img', 'tt', 'div', 'ins', 'del', 'sup', 'sub', 'p', 'ol', 'ul', 'table', 'thead', 'tbody', 'tfoot', 'blockquote', 'dl', 'dt', 'dd', 'kbd', 'q', 'samp', 'var', 'hr', 'ruby', 'rt', 'rp', 'li', 'tr', 'td', 'th', 's', 'strike', 'summary', 'details', 'caption', 'figure', 'figcaption', 'abbr', 'bdo', 'cite', 'dfn', 'mark', 'small', 'span', 'time', 'wbr', 'input'],
  attributes: {
    a: ['href'],
    img: ['src', 'longDesc'],
    input: [['type', 'checkbox'], ['disabled', true]],
    li: [['className', 'task-list-item']],
    div: ['itemScope', 'itemType'],
    blockquote: ['cite'],
    del: ['cite'],
    ins: ['cite'],
    q: ['cite'],
    '*': ['abbr', 'accept', 'acceptCharset', 'accessKey', 'action', 'align', 'alt', 'ariaDescribedBy', 'ariaHidden', 'ariaLabel', 'ariaLabelledBy', 'axis', 'border', 'cellPadding', 'cellSpacing', 'char', 'charOff', 'charSet', 'checked', 'clear', 'cols', 'colSpan', 'color', 'compact', 'coords', 'dateTime', 'dir', 'disabled', 'encType', 'htmlFor', 'frame', 'headers', 'height', 'hrefLang', 'hSpace', 'isMap', 'id', 'label', 'lang', 'maxLength', 'media', 'method', 'multiple', 'name', 'noHref', 'noShade', 'noWrap', 'open', 'prompt', 'readOnly', 'rel', 'rev', 'rows', 'rowSpan', 'rules', 'scope', 'selected', 'shape', 'size', 'span', 'start', 'summary', 'tabIndex', 'target', 'title', 'type', 'useMap', 'vAlign', 'value', 'vSpace', 'width', 'itemProp']
  },
  required: {
    input: {
      type: 'checkbox',
      disabled: true
    }
  }
};

const githubSchema = defaultSchema;
githubSchema.tagNames.push('video', 'source'); // Allow className for all elements

githubSchema.attributes['*'].push('className'); // Allow specific attributes that are required for the page to render properly

githubSchema.attributes.div = ['dataType', 'dataId'];
githubSchema.attributes.blockquote = ['dataId'];
githubSchema.attributes.img = ['dataType', 'src', 'height', 'width'];
githubSchema.attributes.video = ['poster', 'controls', 'preload', 'playsInline', 'autoPlay', 'muted', 'loop'];
githubSchema.attributes.source = ['src'];

const getProcessor = unified().use(parse) // Sanitize the HTML
.use(sanitize, githubSchema).use(rehypeMinify).freeze();
async function htmlToAst(html, context) {
  try {
    const processor = getProcessor().use(rehypeTweet, context);
    const file = await processor.process(html);
    return file.result;
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`HTML to AST error: ${error}`);
    throw error;
  }
}

class Context {
  constructor() {
    this.slugger = new GithubSlugger();
    this.map = [];
  }

  get(id) {
    return this.map[Number(id)];
  }

  add(data, nodes) {
    return this.map.push({
      data,
      nodes
    }) - 1;
  }

}

async function fetchTweetAst(tweetId) {
  const tweetHtml = await fetchTweetHtml(tweetId);
  const tweet = tweetHtml && getTweetData(tweetHtml);
  if (!tweet) return null;
  const context = new Context();
  const html = await getTweetHtml(tweet, context);
  const ast = await htmlToAst(html, context);
  return ast;
}

export { fetchTweetAst };
//# sourceMappingURL=index.module.js.map
