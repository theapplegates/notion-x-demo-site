{"version":3,"sources":["../src/get-text-content.ts","../src/get-block-title.ts","../src/get-block-icon.ts","../src/get-page-title.ts","../src/get-page-property.ts","../src/get-date-value.ts","../src/get-block-parent-page.ts","../src/get-page-table-of-contents.ts","../src/get-page-content-block-ids.ts","../src/id-to-uuid.ts","../src/parse-page-id.ts","../src/uuid-to-id.ts","../src/get-all-pages-in-space.ts","../src/get-canonical-page-id.ts","../src/get-page-breadcrumbs.ts","../src/get-page-image-urls.ts","../src/normalize-url.ts"],"sourcesContent":["import * as types from 'notion-types'\n\n/**\n * Gets the raw, unformatted text content of a block's content value.\n *\n * This is useful, for instance, for extracting a block's `title` without any\n * rich text formatting.\n */\nexport const getTextContent = (text?: types.Decoration[]): string => {\n  if (!text) {\n    return ''\n  } else if (Array.isArray(text)) {\n    return (\n      text?.reduce(\n        (prev, current) =>\n          prev + (current[0] !== '⁍' && current[0] !== '‣' ? current[0] : ''),\n        ''\n      ) ?? ''\n    )\n  } else {\n    return text\n  }\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\nimport { getTextContent } from './get-text-content'\n\nexport function getBlockTitle(block: Block, recordMap: ExtendedRecordMap) {\n  if (block.properties?.title) {\n    return getTextContent(block.properties.title)\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collection = recordMap.collection[block.collection_id]?.value\n\n    if (collection) {\n      return getTextContent(collection.name)\n    }\n  }\n\n  return ''\n}\n","import { Block, PageBlock, ExtendedRecordMap } from 'notion-types'\n\nexport function getBlockIcon(block: Block, recordMap: ExtendedRecordMap) {\n  if ((block as PageBlock).format?.page_icon) {\n    return (block as PageBlock).format?.page_icon\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collection = recordMap.collection[block.collection_id]?.value\n\n    if (collection) {\n      return collection.icon\n    }\n  }\n\n  return null\n}\n","import { ExtendedRecordMap } from 'notion-types'\nimport { getBlockTitle } from './get-block-title'\n\nexport function getPageTitle(recordMap: ExtendedRecordMap) {\n  const pageBlock = recordMap.block[Object.keys(recordMap.block)[0]]?.value\n\n  if (pageBlock) {\n    return getBlockTitle(pageBlock, recordMap)\n  }\n\n  return null\n}\n","import { Block, DateFormat, ExtendedRecordMap } from 'notion-types'\nimport { getTextContent } from './get-text-content'\n\n/**\n * Gets the value of a collection property for a given page (collection item).\n *\n * @param propertyName property name\n * @param block Page block, often be first block in blockMap\n * @param recordMap\n * @returns - The return value types will follow the following principles:\n *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)\n *  2. property is text-like will return `string`\n *  3. multi select property will return `string[]`\n *  4. checkbox property return `boolean`\n * @todo complete all no-text property type\n */\nexport function getPageProperty<\n  T = string | number | boolean | string[] | number[]\n>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T\nexport function getPageProperty(\n  propertyName: string,\n  block: Block,\n  recordMap: ExtendedRecordMap\n) {\n  try {\n    if (!block.properties || !Object.keys(recordMap.collection)) {\n      // console.warn(\n      //   `block ${block.id} has no properties or this recordMap has no collection record`\n      // )\n      return null\n    }\n\n    const collection = recordMap.collection[block.parent_id]?.value\n\n    if (collection) {\n      const propertyId = Object.keys(collection.schema).find(\n        (key) => collection.schema[key]?.name === propertyName\n      )\n\n      if (!propertyId) {\n        return null\n      }\n\n      const { type } = collection.schema[propertyId]\n      const content = getTextContent(block.properties[propertyId])\n\n      switch (type) {\n        case 'created_time':\n          return block.created_time\n\n        case 'multi_select':\n          return content.split(',')\n\n        case 'date': {\n          const property = block.properties[propertyId] as [['‣', [DateFormat]]]\n          const formatDate = property[0][1][0][1]\n          if (formatDate.type == 'datetime') {\n            return new Date(\n              `${formatDate.start_date} ${formatDate.start_time}`\n            ).getTime()\n          } else if (formatDate.type == 'date') {\n            return new Date(formatDate.start_date).getTime()\n          } else if (formatDate.type == 'datetimerange') {\n            const { start_date, start_time, end_date, end_time } = formatDate\n            const startTime = new Date(`${start_date} ${start_time}`).getTime()\n            const endTime = new Date(`${end_date} ${end_time}`).getTime()\n            return [startTime, endTime]\n          } else {\n            const startTime = new Date(formatDate.start_date).getTime()\n            const endTime = new Date(formatDate.end_date).getTime()\n            return [startTime, endTime]\n          }\n        }\n\n        case 'checkbox':\n          return content == 'Yes'\n\n        case 'last_edited_time':\n          return block.last_edited_time\n\n        default:\n          return content\n      }\n    }\n  } catch {\n    // ensure that no matter what, we don't throw errors because of an unexpected\n    // collection data format\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Attempts to find a valid date from a given property.\n */\nexport const getDateValue = (prop: any[]): types.FormattedDate | null => {\n  if (prop && Array.isArray(prop)) {\n    if (prop[0] === 'd') {\n      return prop[1]\n    } else {\n      for (const v of prop) {\n        const value = getDateValue(v)\n        if (value) {\n          return value\n        }\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Returns the parent page block containing a given page.\n *\n * Note that many times this will not be the direct parent block since\n * some non-page content blocks can contain sub-blocks.\n */\nexport const getBlockParentPage = (\n  block: types.Block,\n  recordMap: types.ExtendedRecordMap,\n  {\n    inclusive = false\n  }: {\n    inclusive?: boolean\n  } = {}\n): types.PageBlock | null => {\n  let currentRecord: types.Block | types.Collection = block\n\n  while (currentRecord != null) {\n    if (inclusive && (currentRecord as types.Block)?.type === 'page') {\n      return currentRecord as types.PageBlock\n    }\n\n    const parentId: string = currentRecord.parent_id\n    const parentTable = currentRecord.parent_table\n\n    if (!parentId) {\n      break\n    }\n\n    if (parentTable === 'collection') {\n      currentRecord = recordMap.collection[parentId]?.value\n    } else {\n      currentRecord = recordMap.block[parentId]?.value\n\n      if ((currentRecord as types.Block)?.type === 'page') {\n        return currentRecord as types.PageBlock\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\nimport { getTextContent } from './get-text-content'\n\nexport interface TableOfContentsEntry {\n  id: types.ID\n  type: types.BlockType\n  text: string\n  indentLevel: number\n}\n\nconst indentLevels = {\n  header: 0,\n  sub_header: 1,\n  sub_sub_header: 2\n}\n\n/**\n * Gets the metadata for a table of contents block by parsing the page's\n * H1, H2, and H3 elements.\n */\nexport const getPageTableOfContents = (\n  page: types.PageBlock,\n  recordMap: types.ExtendedRecordMap\n): Array<TableOfContentsEntry> => {\n  const toc = (page.content ?? [])\n    .map((blockId: string) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (block) {\n        const { type } = block\n\n        if (\n          type === 'header' ||\n          type === 'sub_header' ||\n          type === 'sub_sub_header'\n        ) {\n          return {\n            id: blockId,\n            type,\n            text: getTextContent(block.properties?.title),\n            indentLevel: indentLevels[type]\n          }\n        }\n      }\n\n      return null\n    })\n    .filter(Boolean) as Array<TableOfContentsEntry>\n\n  const indentLevelStack = [\n    {\n      actual: -1,\n      effective: -1\n    }\n  ]\n\n  // Adjust indent levels to always change smoothly.\n  // This is a little tricky, but the key is that when increasing indent levels,\n  // they should never jump more than one at a time.\n  for (const tocItem of toc) {\n    const { indentLevel } = tocItem\n    const actual = indentLevel\n\n    do {\n      const prevIndent = indentLevelStack[indentLevelStack.length - 1]\n      const { actual: prevActual, effective: prevEffective } = prevIndent\n\n      if (actual > prevActual) {\n        tocItem.indentLevel = prevEffective + 1\n        indentLevelStack.push({\n          actual,\n          effective: tocItem.indentLevel\n        })\n      } else if (actual === prevActual) {\n        tocItem.indentLevel = prevEffective\n        break\n      } else {\n        indentLevelStack.pop()\n      }\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true)\n  }\n\n  return toc\n}\n","import * as types from 'notion-types'\n\n/**\n * Gets the IDs of all blocks contained on a page starting from a root block ID.\n */\nexport const getPageContentBlockIds = (\n  recordMap: types.ExtendedRecordMap,\n  blockId?: string\n): string[] => {\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0]\n  const contentBlockIds = new Set<string>()\n\n  function addContentBlocks(blockId: string) {\n    if (contentBlockIds.has(blockId)) return\n    contentBlockIds.add(blockId)\n\n    const block = recordMap.block[blockId]?.value\n    if (!block) return\n\n    const { content, type } = block\n    if (!content) return\n\n    if (type === 'page' && blockId !== rootBlockId) {\n      // ignore subpages\n      return\n    }\n\n    for (const blockId of content) {\n      addContentBlocks(blockId)\n    }\n  }\n\n  addContentBlocks(rootBlockId)\n\n  for (const blockId of Object.keys(recordMap.block)) {\n    const block = recordMap.block[blockId]?.value\n    if (!block) continue\n\n    const { properties } = block\n\n    if (properties) {\n      // TODO: this needs some love, especially for resolving relation properties\n      // see this collection_view_page for an example: 8a586d253f984b85b48254da84465d23\n      for (const key of Object.keys(properties)) {\n        const p = properties[key]\n        p.map((d: any) => {\n          const value = d?.[0]?.[1]?.[0]\n          if (value?.[0] === 'p' && value[1]) {\n            contentBlockIds.add(value[1])\n          }\n        })\n\n        // [[\"‣\", [[\"p\", \"841918aa-f2a3-4d4c-b5ad-64b0f57c47b8\"]]]]\n        const value = p?.[0]?.[1]?.[0]\n\n        if (value?.[0] === 'p' && value[1]) {\n          contentBlockIds.add(value[1])\n        }\n      }\n    }\n  }\n\n  return Array.from(contentBlockIds)\n}\n","export const idToUuid = (id = '') =>\n  `${id.substr(0, 8)}-${id.substr(8, 4)}-${id.substr(12, 4)}-${id.substr(\n    16,\n    4\n  )}-${id.substr(20)}`\n","import { idToUuid } from './id-to-uuid'\n\nconst pageIdRe = /\\b([a-f0-9]{32})\\b/\nconst pageId2Re =\n  /\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/\n\n/**\n * Robustly extracts the notion page ID from a notion URL or pathname suffix.\n *\n * Defaults to returning a UUID (with dashes).\n */\nexport const parsePageId = (\n  id: string | null = '',\n  { uuid = true }: { uuid?: boolean } = {}\n) => {\n  if (!id) {\n    return null\n  }\n\n  id = id.split('?')[0]\n  const match = id.match(pageIdRe)\n\n  if (match) {\n    return uuid ? idToUuid(match[1]) : match[1]\n  }\n\n  const match2 = id.match(pageId2Re)\n  if (match2) {\n    return uuid ? match2[1] : match2[1].replace(/-/g, '')\n  }\n\n  return null\n}\n","export const uuidToId = (uuid: string) => uuid.replace(/-/g, '')\n","import PQueue from 'p-queue'\n\nimport { ExtendedRecordMap, PageMap } from 'notion-types'\nimport { parsePageId } from './parse-page-id'\n\n/**\n * Performs a traversal over a given Notion workspace starting from a seed page.\n *\n * Returns a map containing all of the pages that are reachable from the seed\n * page in the space.\n *\n * If `rootSpaceId` is not defined, the space ID of the root page will be used\n * to scope traversal.\n *\n *\n * @param rootPageId - Page ID to start from.\n * @param rootSpaceId - Space ID to scope traversal.\n * @param getPage - Function used to fetch a single page.\n * @param opts - Optional config\n */\nexport async function getAllPagesInSpace(\n  rootPageId: string,\n  rootSpaceId: string | undefined,\n  getPage: (pageId: string) => Promise<ExtendedRecordMap>,\n  {\n    concurrency = 4,\n    traverseCollections = true,\n    targetPageId = null\n  }: {\n    concurrency?: number\n    traverseCollections?: boolean\n    targetPageId?: string\n  } = {}\n): Promise<PageMap> {\n  const pages: PageMap = {}\n  const pendingPageIds = new Set<string>()\n  const queue = new PQueue({ concurrency })\n\n  async function processPage(pageId: string) {\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\n      return\n    }\n\n    pageId = parsePageId(pageId) as string\n\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\n      pendingPageIds.add(pageId)\n\n      queue.add(async () => {\n        try {\n          if (\n            targetPageId &&\n            pendingPageIds.has(targetPageId) &&\n            pageId !== targetPageId\n          ) {\n            return\n          }\n\n          const page = await getPage(pageId)\n          if (!page) {\n            return\n          }\n\n          const spaceId = page.block[pageId]?.value?.space_id\n\n          if (!rootSpaceId) {\n            rootSpaceId = spaceId\n          } else if (rootSpaceId !== spaceId) {\n            return\n          }\n\n          Object.keys(page.block)\n            .filter((key) => {\n              const block = page.block[key]?.value\n              if (!block) return false\n\n              const isPage =\n                block.type === 'page' || block.type === 'collection_view_page'\n\n              // the space id check is important to limit traversal because pages\n              // can reference pages in other spaces\n              return isPage && block.space_id === rootSpaceId\n            })\n            .forEach((subPageId) => processPage(subPageId))\n\n          // traverse collection item pages as they may contain subpages as well\n          if (traverseCollections) {\n            for (const collectionViews of Object.values(\n              page.collection_query\n            )) {\n              for (const collectionData of Object.values(collectionViews)) {\n                const { blockIds } = collectionData\n\n                if (blockIds) {\n                  for (const collectionItemId of blockIds) {\n                    processPage(collectionItemId)\n                  }\n                }\n              }\n            }\n          }\n\n          pages[pageId] = page\n        } catch (err) {\n          console.warn(\n            'page load error',\n            { pageId, spaceId: rootSpaceId },\n            err.statusCode,\n            err.message\n          )\n          pages[pageId] = null\n        }\n\n        pendingPageIds.delete(pageId)\n      })\n    }\n  }\n\n  await processPage(rootPageId)\n  await queue.onIdle()\n\n  return pages\n}\n","import { ExtendedRecordMap } from 'notion-types'\nimport { uuidToId } from './uuid-to-id'\nimport { getBlockTitle } from './get-block-title'\nimport { getPageProperty } from './get-page-property'\n\n/**\n * Gets the canonical, display-friendly version of a page's ID for use in URLs.\n */\nexport const getCanonicalPageId = (\n  pageId: string,\n  recordMap: ExtendedRecordMap,\n  { uuid = true }: { uuid?: boolean } = {}\n): string | null => {\n  if (!pageId || !recordMap) return null\n\n  const id = uuidToId(pageId)\n  const block = recordMap.block[pageId]?.value\n\n  if (block) {\n    const slug =\n      (getPageProperty('slug', block, recordMap) as string | null) ||\n      (getPageProperty('Slug', block, recordMap) as string | null) ||\n      normalizeTitle(getBlockTitle(block, recordMap))\n\n    if (slug) {\n      if (uuid) {\n        return `${slug}-${id}`\n      } else {\n        return slug\n      }\n    }\n  }\n\n  return id\n}\n\nexport const normalizeTitle = (title: string | null): string => {\n  return (title || '')\n    .replace(/ /g, '-')\n    .replace(/[^a-zA-Z0-9-\\u4e00-\\u9fa5]/g, '')\n    .replace(/--/g, '-')\n    .replace(/-$/, '')\n    .replace(/^-/, '')\n    .trim()\n    .toLowerCase()\n}\n","import * as types from 'notion-types'\nimport { getBlockTitle } from './get-block-title'\nimport { getBlockIcon } from './get-block-icon'\nimport { getBlockParentPage } from './get-block-parent-page'\n\nexport const getPageBreadcrumbs = (\n  recordMap: types.ExtendedRecordMap,\n  activePageId: string\n): Array<any> | null => {\n  const blockMap = recordMap.block\n  const breadcrumbs = []\n\n  let currentPageId = activePageId\n\n  do {\n    const block = blockMap[currentPageId]?.value\n    if (!block) {\n      break\n    }\n\n    const title = getBlockTitle(block, recordMap)\n    const icon = getBlockIcon(block, recordMap)\n\n    if (!(title || icon)) {\n      break\n    }\n\n    breadcrumbs.push({\n      block,\n      active: currentPageId === activePageId,\n      pageId: currentPageId,\n      title,\n      icon\n    })\n\n    const parentBlock = getBlockParentPage(block, recordMap)\n    const parentId = parentBlock?.id\n\n    if (!parentId) {\n      break\n    }\n\n    currentPageId = parentId\n\n    // eslint-disable-next-line no-constant-condition\n  } while (true)\n\n  breadcrumbs.reverse()\n\n  return breadcrumbs\n}\n","import isUrl from 'is-url-superb'\nimport * as types from 'notion-types'\nimport { getBlockIcon } from './get-block-icon'\n\n/**\n * Gets URLs of all images contained on the given page.\n */\nexport const getPageImageUrls = (\n  recordMap: types.ExtendedRecordMap,\n  {\n    mapImageUrl\n  }: {\n    mapImageUrl: (url: string, block: types.Block) => string | null\n  }\n): string[] => {\n  const blockIds = Object.keys(recordMap.block)\n  const imageUrls: string[] = blockIds\n    .flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n      const images: Array<{ block: types.Block; url: string }> = []\n\n      if (block) {\n        if (block.type === 'image') {\n          const signedUrl = recordMap.signed_urls?.[block.id]\n          const source = signedUrl || block.properties?.source?.[0]?.[0]\n\n          if (source) {\n            images.push({\n              block,\n              url: source\n            })\n          }\n        }\n\n        if ((block.format as any)?.page_cover) {\n          const source = (block.format as any).page_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_cover) {\n          const source = (block.format as any).bookmark_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_icon) {\n          const source = (block.format as any).bookmark_icon\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        const pageIcon = getBlockIcon(block, recordMap)\n        if (pageIcon && isUrl(pageIcon)) {\n          images.push({\n            block,\n            url: pageIcon\n          })\n        }\n      }\n\n      return images\n    })\n    .filter(Boolean)\n    .map(({ block, url }) => mapImageUrl(url, block))\n    .filter(Boolean)\n\n  return Array.from(new Set(imageUrls))\n}\n","import normalizeUrlImpl from 'normalize-url'\nimport mem from 'mem'\n\nexport const normalizeUrl = mem((url?: string) => {\n  if (!url) {\n    return ''\n  }\n\n  try {\n    if (url.startsWith('https://www.notion.so/image/')) {\n      const u = new URL(url)\n      const subUrl = decodeURIComponent(u.pathname.substr('/image/'.length))\n      const normalizedSubUrl = normalizeUrl(subUrl)\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`\n      url = u.toString()\n    }\n\n    return normalizeUrlImpl(url, {\n      stripProtocol: true,\n      stripWWW: true,\n      stripHash: true,\n      stripTextFragment: true,\n      removeQueryParameters: true\n    })\n  } catch (err) {\n    return ''\n  }\n})\n"],"mappings":"6MAQO,GAAM,GAAiB,AAAC,GAAsC,CARrE,MASE,MAAK,GAEM,MAAM,QAAQ,CAAI,EAEzB,oBAAM,OACJ,CAAC,EAAM,IACL,EAAQ,GAAQ,KAAO,UAAO,EAAQ,KAAO,SAAM,EAAQ,GAAK,IAClE,MAHF,OAIK,GAGA,EAVA,EAYX,ECnBO,WAAuB,EAAc,EAA8B,CAH1E,QAIE,GAAI,KAAM,aAAN,QAAkB,MACpB,MAAO,GAAe,EAAM,WAAW,KAAK,EAG9C,GACE,EAAM,OAAS,wBACf,EAAM,OAAS,kBACf,CACA,GAAM,GAAa,KAAU,WAAW,EAAM,iBAA3B,cAA2C,MAE9D,GAAI,EACF,MAAO,GAAe,EAAW,IAAI,CAEzC,CAEA,MAAO,EACT,CClBO,WAAsB,EAAc,EAA8B,CAFzE,UAGE,GAAK,KAAoB,SAApB,QAA4B,UAC/B,MAAQ,KAAoB,SAApB,cAA4B,UAGtC,GACE,EAAM,OAAS,wBACf,EAAM,OAAS,kBACf,CACA,GAAM,GAAa,KAAU,WAAW,EAAM,iBAA3B,cAA2C,MAE9D,GAAI,EACF,MAAO,GAAW,IAEtB,CAEA,MAAO,KACT,CChBO,WAAsB,EAA8B,CAH3D,MAIE,GAAM,GAAY,KAAU,MAAM,OAAO,KAAK,EAAU,KAAK,EAAE,MAA7C,cAAkD,MAEpE,MAAI,GACK,EAAc,EAAW,CAAS,EAGpC,IACT,CCQO,WACL,EACA,EACA,EACA,CAvBF,MAwBE,GAAI,CACF,GAAI,CAAC,EAAM,YAAc,CAAC,OAAO,KAAK,EAAU,UAAU,EAIxD,MAAO,MAGT,GAAM,GAAa,KAAU,WAAW,EAAM,aAA3B,cAAuC,MAE1D,GAAI,EAAY,CACd,GAAM,GAAa,OAAO,KAAK,EAAW,MAAM,EAAE,KAChD,AAAC,GAAK,CApCd,MAoCiB,YAAW,OAAO,KAAlB,cAAwB,QAAS,EAC5C,EAEA,GAAI,CAAC,EACH,MAAO,MAGT,GAAM,CAAE,QAAS,EAAW,OAAO,GAC7B,EAAU,EAAe,EAAM,WAAW,EAAW,EAE3D,OAAQ,OACD,eACH,MAAO,GAAM,iBAEV,eACH,MAAO,GAAQ,MAAM,GAAG,MAErB,OAAQ,CAEX,GAAM,GAAa,AADF,EAAM,WAAW,GACN,GAAG,GAAG,GAAG,GACrC,GAAI,EAAW,MAAQ,WACrB,MAAO,IAAI,MACT,GAAG,EAAW,cAAc,EAAW,YACzC,EAAE,QAAQ,EACL,GAAI,EAAW,MAAQ,OAC5B,MAAO,IAAI,MAAK,EAAW,UAAU,EAAE,QAAQ,EAC1C,GAAI,EAAW,MAAQ,gBAAiB,CAC7C,GAAM,CAAE,aAAY,aAAY,WAAU,YAAa,EACjD,EAAY,GAAI,MAAK,GAAG,KAAc,GAAY,EAAE,QAAQ,EAC5D,EAAU,GAAI,MAAK,GAAG,KAAY,GAAU,EAAE,QAAQ,EAC5D,MAAO,CAAC,EAAW,CAAO,CAC5B,KAAO,CACL,GAAM,GAAY,GAAI,MAAK,EAAW,UAAU,EAAE,QAAQ,EACpD,EAAU,GAAI,MAAK,EAAW,QAAQ,EAAE,QAAQ,EACtD,MAAO,CAAC,EAAW,CAAO,CAC5B,CACF,KAEK,WACH,MAAO,IAAW,UAEf,mBACH,MAAO,GAAM,yBAGb,MAAO,GAEb,CACF,OAAQ,EAAN,CAGF,CAEA,MAAO,KACT,CCrFO,GAAM,GAAe,AAAC,GAA4C,CACvE,GAAI,GAAQ,MAAM,QAAQ,CAAI,EAAG,CAC/B,GAAI,EAAK,KAAO,IACd,MAAO,GAAK,GAEZ,OAAW,KAAK,GAAM,CACpB,GAAM,GAAQ,EAAa,CAAC,EAC5B,GAAI,EACF,MAAO,EAEX,CAEJ,CAEA,MAAO,KACT,ECZO,GAAM,GAAqB,CAChC,EACA,EACA,CACE,YAAY,IAGV,CAAC,IACsB,CAhB7B,QAiBE,GAAI,GAAgD,EAEpD,KAAO,GAAiB,MAAM,CAC5B,GAAI,GAAc,kBAA+B,QAAS,OACxD,MAAO,GAGT,GAAM,GAAmB,EAAc,UACjC,EAAc,EAAc,aAElC,GAAI,CAAC,EACH,MAGF,GAAI,IAAgB,aAClB,EAAgB,KAAU,WAAW,KAArB,cAAgC,cAEhD,EAAgB,KAAU,MAAM,KAAhB,cAA2B,MAEtC,kBAA+B,QAAS,OAC3C,MAAO,EAGb,CAEA,MAAO,KACT,ECjCA,GAAM,GAAe,CACnB,OAAQ,EACR,WAAY,EACZ,eAAgB,CAClB,EAMa,GAAyB,CACpC,EACA,IACgC,CAvBlC,MAwBE,GAAM,GAAO,MAAK,UAAL,OAAgB,CAAC,GAC3B,IAAI,AAAC,GAAoB,CAzB9B,QA0BM,GAAM,GAAQ,KAAU,MAAM,KAAhB,cAA0B,MAExC,GAAI,EAAO,CACT,GAAM,CAAE,QAAS,EAEjB,GACE,IAAS,UACT,IAAS,cACT,IAAS,iBAET,MAAO,CACL,GAAI,EACJ,OACA,KAAM,EAAe,KAAM,aAAN,cAAkB,KAAK,EAC5C,YAAa,EAAa,EAC5B,CAEJ,CAEA,MAAO,KACT,CAAC,EACA,OAAO,OAAO,EAEX,EAAmB,CACvB,CACE,OAAQ,GACR,UAAW,EACb,CACF,EAKA,OAAW,KAAW,GAAK,CACzB,GAAM,CAAE,eAAgB,EAClB,EAAS,EAEf,EAAG,CACD,GAAM,GAAa,EAAiB,EAAiB,OAAS,GACxD,CAAE,OAAQ,EAAY,UAAW,GAAkB,EAEzD,GAAI,EAAS,EACX,EAAQ,YAAc,EAAgB,EACtC,EAAiB,KAAK,CACpB,SACA,UAAW,EAAQ,WACrB,CAAC,UACQ,IAAW,EAAY,CAChC,EAAQ,YAAc,EACtB,KACF,KACE,GAAiB,IAAI,CAIzB,OAAS,GACX,CAEA,MAAO,EACT,EChFO,GAAM,IAAyB,CACpC,EACA,IACa,CARf,UASE,GAAM,GAAc,GAAW,OAAO,KAAK,EAAU,KAAK,EAAE,GACtD,EAAkB,GAAI,KAE5B,WAA0B,EAAiB,CAZ7C,MAaI,GAAI,EAAgB,IAAI,CAAO,EAAG,OAClC,EAAgB,IAAI,CAAO,EAE3B,GAAM,GAAQ,KAAU,MAAM,KAAhB,cAA0B,MACxC,GAAI,CAAC,EAAO,OAEZ,GAAM,CAAE,UAAS,QAAS,EAC1B,GAAI,EAAC,GAED,MAAS,QAAU,IAAY,GAKnC,OAAW,KAAW,GACpB,EAAiB,CAAO,CAE5B,CAEA,EAAiB,CAAW,EAE5B,OAAW,KAAW,QAAO,KAAK,EAAU,KAAK,EAAG,CAClD,GAAM,GAAQ,KAAU,MAAM,KAAhB,cAA0B,MACxC,GAAI,CAAC,EAAO,SAEZ,GAAM,CAAE,cAAe,EAEvB,GAAI,EAGF,OAAW,KAAO,QAAO,KAAK,CAAU,EAAG,CACzC,GAAM,GAAI,EAAW,GACrB,EAAE,IAAI,AAAC,GAAW,CA7C1B,QA8CU,GAAM,GAAQ,uBAAI,KAAJ,cAAS,KAAT,cAAc,GAC5B,AAAI,kBAAQ,MAAO,KAAO,EAAM,IAC9B,EAAgB,IAAI,EAAM,EAAE,CAEhC,CAAC,EAGD,GAAM,GAAQ,uBAAI,KAAJ,cAAS,KAAT,cAAc,GAE5B,AAAI,kBAAQ,MAAO,KAAO,EAAM,IAC9B,EAAgB,IAAI,EAAM,EAAE,CAEhC,CAEJ,CAEA,MAAO,OAAM,KAAK,CAAe,CACnC,EC/DO,GAAM,GAAW,CAAC,EAAK,KAC5B,GAAG,EAAG,OAAO,EAAG,CAAC,KAAK,EAAG,OAAO,EAAG,CAAC,KAAK,EAAG,OAAO,GAAI,CAAC,KAAK,EAAG,OAC9D,GACA,CACF,KAAK,EAAG,OAAO,EAAE,ICFnB,GAAM,GAAW,qBACX,EACJ,qEAOW,EAAc,CACzB,EAAoB,GACpB,CAAE,OAAO,IAA6B,CAAC,IACpC,CACH,GAAI,CAAC,EACH,MAAO,MAGT,EAAK,EAAG,MAAM,GAAG,EAAE,GACnB,GAAM,GAAQ,EAAG,MAAM,CAAQ,EAE/B,GAAI,EACF,MAAO,GAAO,EAAS,EAAM,EAAE,EAAI,EAAM,GAG3C,GAAM,GAAS,EAAG,MAAM,CAAS,EACjC,MAAI,GACK,EAAO,EAAO,GAAK,EAAO,GAAG,QAAQ,KAAM,EAAE,EAG/C,IACT,EChCO,GAAM,GAAW,AAAC,GAAiB,EAAK,QAAQ,KAAM,EAAE,ECA/D,uBAoBA,YACE,EACA,EACA,EAUkB,mCAZlB,EACA,EACA,EACA,CACE,cAAc,EACd,sBAAsB,GACtB,eAAe,MAKb,CAAC,EACa,CAClB,GAAM,GAAiB,CAAC,EAClB,EAAiB,GAAI,KACrB,EAAQ,GAAI,GAAO,CAAE,aAAY,CAAC,EAExC,WAA2B,EAAgB,gCACzC,AAAI,GAAgB,EAAe,IAAI,CAAY,GAInD,GAAS,EAAY,CAAM,EAEvB,GAAU,CAAC,EAAM,IAAW,CAAC,EAAe,IAAI,CAAM,GACxD,GAAe,IAAI,CAAM,EAEzB,EAAM,IAAI,IAAY,wBAhD5B,QAiDQ,GAAI,CACF,GACE,GACA,EAAe,IAAI,CAAY,GAC/B,IAAW,EAEX,OAGF,GAAM,GAAO,KAAM,GAAQ,CAAM,EACjC,GAAI,CAAC,EACH,OAGF,GAAM,GAAU,QAAK,MAAM,KAAX,cAAoB,QAApB,cAA2B,SAE3C,GAAI,CAAC,EACH,EAAc,UACL,IAAgB,EACzB,OAkBF,GAfA,OAAO,KAAK,EAAK,KAAK,EACnB,OAAO,AAAC,GAAQ,CAxE7B,MAyEc,GAAM,GAAQ,KAAK,MAAM,KAAX,cAAiB,MAC/B,MAAK,GAOE,AAJL,GAAM,OAAS,QAAU,EAAM,OAAS,yBAIzB,EAAM,WAAa,EAPjB,EAQrB,CAAC,EACA,QAAQ,AAAC,GAAc,EAAY,CAAS,CAAC,EAG5C,EACF,OAAW,KAAmB,QAAO,OACnC,EAAK,gBACP,EACE,OAAW,KAAkB,QAAO,OAAO,CAAe,EAAG,CAC3D,GAAM,CAAE,YAAa,EAErB,GAAI,EACF,OAAW,KAAoB,GAC7B,EAAY,CAAgB,CAGlC,CAIJ,EAAM,GAAU,CAClB,OAAS,EAAP,CACA,QAAQ,KACN,kBACA,CAAE,SAAQ,QAAS,CAAY,EAC/B,EAAI,WACJ,EAAI,OACN,EACA,EAAM,GAAU,IAClB,CAEA,EAAe,OAAO,CAAM,CAC9B,EAAC,GAEL,GAEA,YAAM,GAAY,CAAU,EAC5B,KAAM,GAAM,OAAO,EAEZ,CACT,GClHO,GAAM,IAAqB,CAChC,EACA,EACA,CAAE,OAAO,IAA6B,CAAC,IACrB,CAZpB,MAaE,GAAI,CAAC,GAAU,CAAC,EAAW,MAAO,MAElC,GAAM,GAAK,EAAS,CAAM,EACpB,EAAQ,KAAU,MAAM,KAAhB,cAAyB,MAEvC,GAAI,EAAO,CACT,GAAM,GACH,EAAgB,OAAQ,EAAO,CAAS,GACxC,EAAgB,OAAQ,EAAO,CAAS,GACzC,EAAe,EAAc,EAAO,CAAS,CAAC,EAEhD,GAAI,EACF,MAAI,GACK,GAAG,KAAQ,IAEX,CAGb,CAEA,MAAO,EACT,EAEa,EAAiB,AAAC,GACrB,IAAS,IACd,QAAQ,KAAM,GAAG,EACjB,QAAQ,8BAA+B,EAAE,EACzC,QAAQ,MAAO,GAAG,EAClB,QAAQ,KAAM,EAAE,EAChB,QAAQ,KAAM,EAAE,EAChB,KAAK,EACL,YAAY,ECvCV,GAAM,IAAqB,CAChC,EACA,IACsB,CARxB,MASE,GAAM,GAAW,EAAU,MACrB,EAAc,CAAC,EAEjB,EAAgB,EAEpB,EAAG,CACD,GAAM,GAAQ,KAAS,KAAT,cAAyB,MACvC,GAAI,CAAC,EACH,MAGF,GAAM,GAAQ,EAAc,EAAO,CAAS,EACtC,EAAO,EAAa,EAAO,CAAS,EAE1C,GAAI,CAAE,IAAS,GACb,MAGF,EAAY,KAAK,CACf,QACA,OAAQ,IAAkB,EAC1B,OAAQ,EACR,QACA,MACF,CAAC,EAED,GAAM,GAAc,EAAmB,EAAO,CAAS,EACjD,EAAW,iBAAa,GAE9B,GAAI,CAAC,EACH,MAGF,EAAgB,CAGlB,OAAS,IAET,SAAY,QAAQ,EAEb,CACT,EClDA,6BAOO,GAAM,IAAmB,CAC9B,EACA,CACE,iBAIW,CAEb,GAAM,GAAsB,AADX,OAAO,KAAK,EAAU,KAAK,EAEzC,QAAQ,AAAC,GAAY,CAjB1B,oBAkBM,GAAM,GAAQ,KAAU,MAAM,KAAhB,cAA0B,MAClC,EAAqD,CAAC,EAE5D,GAAI,EAAO,CACT,GAAI,EAAM,OAAS,QAAS,CAE1B,GAAM,GAAS,AADG,MAAU,cAAV,cAAwB,EAAM,MACpB,YAAM,aAAN,cAAkB,SAAlB,cAA2B,KAA3B,cAAgC,IAE5D,AAAI,GACF,EAAO,KAAK,CACV,QACA,IAAK,CACP,CAAC,CAEL,CAEA,GAAK,KAAM,SAAN,QAAsB,WAAY,CACrC,GAAM,GAAU,EAAM,OAAe,WAErC,EAAO,KAAK,CACV,QACA,IAAK,CACP,CAAC,CACH,CAEA,GAAK,KAAM,SAAN,QAAsB,eAAgB,CACzC,GAAM,GAAU,EAAM,OAAe,eAErC,EAAO,KAAK,CACV,QACA,IAAK,CACP,CAAC,CACH,CAEA,GAAK,KAAM,SAAN,QAAsB,cAAe,CACxC,GAAM,GAAU,EAAM,OAAe,cAErC,EAAO,KAAK,CACV,QACA,IAAK,CACP,CAAC,CACH,CAEA,GAAM,GAAW,EAAa,EAAO,CAAS,EAC9C,AAAI,GAAY,EAAM,CAAQ,GAC5B,EAAO,KAAK,CACV,QACA,IAAK,CACP,CAAC,CAEL,CAEA,MAAO,EACT,CAAC,EACA,OAAO,OAAO,EACd,IAAI,CAAC,CAAE,QAAO,SAAU,EAAY,EAAK,CAAK,CAAC,EAC/C,OAAO,OAAO,EAEjB,MAAO,OAAM,KAAK,GAAI,KAAI,CAAS,CAAC,CACtC,EC7EA,6BACA,mBAEO,GAAM,GAAe,EAAI,AAAC,GAAiB,CAChD,GAAI,CAAC,EACH,MAAO,GAGT,GAAI,CACF,GAAI,EAAI,WAAW,8BAA8B,EAAG,CAClD,GAAM,GAAI,GAAI,KAAI,CAAG,EACf,EAAS,mBAAmB,EAAE,SAAS,OAAO,CAAgB,CAAC,EAC/D,EAAmB,EAAa,CAAM,EAC5C,EAAE,SAAW,UAAU,mBAAmB,CAAgB,IAC1D,EAAM,EAAE,SAAS,CACnB,CAEA,MAAO,GAAiB,EAAK,CAC3B,cAAe,GACf,SAAU,GACV,UAAW,GACX,kBAAmB,GACnB,sBAAuB,EACzB,CAAC,CACH,OAAS,EAAP,CACA,MAAO,EACT,CACF,CAAC","names":[]}